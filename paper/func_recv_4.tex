% -*- mode: LaTeX; mode: TeX-PDF; coding: utf-8  -*-

%\section{БСКП  
%  алгоритмы восстановления данных по известным значениям 
%  в узлах равномерной сетки}
%  %с применением 
%  %аппарата средних В.~А.~Стеклова}

\label{sec:func_recv}


%\subsection*{Основные обозначения}
\subsection*{Алгоритм восстановления данных}



% Рассмотрим подробнее выбранный алгоритм восстановления данных,
% предложенный в работе~\cite{book_Zhuk}. 



% Пусть
% $ \rho \in \mathbb{N}$, $t\in\mathbb{R}$, 
% %тогда 
% ядро В.~А.~Стеклова порядка $\rho$ определяется формулой
% \begin{equation}
%     \label{eq:psi_common}
%     \psi_{\rho}(t)=
%     \begin{cases}
%       \dfrac{1}{(\rho-1)!}\sum\limits_{0\leqslant k<\left(|t|+\frac{\rho}{2}\right)}(-1)^kC_{\rho}^k\left(|t|+\dfrac{\rho}{2}-k\right)^{\rho-1},\ \text{если}\ |t|\leqslant \dfrac{\rho}{2},\\
%      0,\ \text{если}\ |t| > \dfrac{\rho}{2}.
%     \end{cases} 
% \end{equation}

% Если рассматривается некоторая величина $x\in\mathbb{R}^2,$ то
% $x_k$ ($k=1,2$) обозначает ее $k$-ю координату.
 
% Пусть $t=(t_1,t_2),\ r=(r_1,r_2),\ r_1,r_2 \in \mathbb{N},\  w = (w_1,w_2),\ w_1,w_2 > 0.$
%     \begin{equation*}
%       \psi_{w,r}(t)=\psi_{w_1,r_1}(t_1)\psi_{w_2,r_2}(t_2).
%     \end{equation*}


%     %В настоящей работе нам потребуются
% Например,     
% частные случаи формулы~\eqref{eq:psi_common} для 
% ядер порядков 2 и 4, приведённые, соответственно, ниже 
% \begin{align}
%   \label{eq:psi_2}
%   &\psi_{2}(t)=
%   \begin{cases}
%       1-|t|,
%       &\ \text{если}\ |t|\leqslant 1,\\
%       0,&\ \text{если}\ |t| > 1;
%   \end{cases}
% \end{align}
% \begin{align}
%   \label{eq:psi_4}
%   &\psi_{4}(t)=\frac{1}{6}
%   \begin{cases}
%     3|t|^3-6t^2+4,
%     &\ \text{если}\ |t|\leqslant 1,\\
%     -|t|^3+6t^2-12|t|+8,
%     &\ \text{если}\ 1<|t|\leqslant 2,\\
%     0,&\ \text{если}\ |t| > 2.
%   \end{cases}
% \end{align}


% Восстановление значений функции $\varphi$ на мелкой сетке %в узле $x$, 
% %согласно выбранному алгоритму~\cite{book_Zhuk},
% выполняется следующим образом: 
% %определяется следующим образом: 

\begin{comment}
1D случай :: Оставим для примера
\begin{equation}
  \label{eq:recv_common}
  \mathcal{G}_r(\varphi, x, h) = \sum_{k=-\left \lfloor \frac{r+1}{2} \right \rfloor}^{K-1+\left \lfloor \frac{r+1}{2} \right \rfloor}
  \varphi(u^{(k)})
  \psi_{r+2}\left(\frac{x}{h}-k}\right),
\end{equation}
где $\psi_{h,r+2}(x-u^{(k)})$ ---  ядро В. А. Стеклова порядка $r+2$ с шагом $h$ (см., например,~\cite{book_Zhuk}),
$r$ --- целое число, $h>0$.
\end{comment}

%2D случай
%\emph{нижние индексы x -- 1, y -- 2}
% \begin{equation}
%   \label{eq:recv_common}
% %  \begin{split}
%    G_h(\varphi, \boldsymbol{m}) = \sum_{\boldsymbol{k}}^K
%    \varphi(u^{(\boldsymbol{k})})
%    \psi_{\boldsymbol{h}, \boldsymbol{r}}(u^{(\boldsymbol{m})}-u^{(\boldsymbol{k})}) = 
%    \sum_{k_2=-\left \lfloor \frac{r_2+1}{2} \right \rfloor}^{K_y-1+\left \lfloor \frac{r_2+1}{2} \right \rfloor}
%    \psi_{h_2,r_2+2}(m_2-k_2) 
%      \sum_{k_1=-\left \lfloor \frac{r_1+1}{2} \right \rfloor}^{K_x-1+\left \lfloor \frac{r_1+1}{2} \right \rfloor}
%      \varphi(u^{(\boldsymbol{k})})\psi_{h_1,r_1+2}(m_1-k_1).
% %   \end{split}
%  \end{equation}
%где %, в общем случае,
%$x$ произвольно расположен между узлами исходной равномерной сетки
%$u^{(k_x, k_y)} = (k_xh_1, k_yh_2)$, $h_1>0$, $h_2>0$.

Восстановление значения в произвольном  узле $x$    мелкой сетки %в узле $x$,
$r$ раз непрерывно дифференцируемой функции $\varphi$
выполняется следующим образом: 
\begin{gather}
  \label{eq:recv_common}
  G_h(\varphi, x) = \sum_{k\in  \Delta_{K,r}}
   \varphi(u^{(k)})
   \psi_{h, r+\mathbf{2}^n}(x-u^{(k)}),%\\ \notag \text{где}\ 
 \end{gather}
 где $ \Delta_{K,r}=\left[-\lfloor{(r+1)/2}\rfloor,
   (K-\mathbf{1}^n)h+\lfloor{(r+1)/2}\rfloor\right]\cap\mathbb{Z}_+^n$.
Из формулы~\eqref{eq:recv_common} следует, что для вычислений
могут быть нужны дополнительные
узлы по краям исходной сетки.
%Будем считать, что они  
%определены некоторым образом.
Способы выбора значений в этих узлах зависят
от специфики задачи для которой применяется формула~\eqref{eq:recv_common}  
и в данной работе не рассматриваются.

\begin{comment}

  -->Перенесено в начало!
 
Будем полагать, что $K$ узлов в которых известны значения функции $\varphi$
расположены на отрезке $[0, K-1]$ с единичным шагом ($h=1$).
%Тогда $u^{(k)} = k$, где $k = 0, \ldots, K-1$.
Сетку с известными значениями в узлах будем называть \textit{крупной сеткой}.
%Между узлами крупной сетки
%(на каждом интервале $[k, k+1], k = 0, \ldots, K-2$)
%располагается по $N$ узлов (с шагом $\frac{1}{N}$),
%в которых 
%требуется найти значения функции $g$.
Требуется вычислить значения 
в $M$ узлах,
равномерно расположенных на исходном отрезке,
где $N$ --- произвольное натуральное число.
Сетку размером $M = N(K-1) + K$ будем называть
\textit{мелкой сеткой}.
Обозначим $N^* = N+1$.
В этих обозначениях количество узлов мелкой сетки $M = N^* (K-1) + 1$.

%Расположение узлов показано на рисунке~\ref{fig:reg_net}.
%\begin{figure}[h!]
%  \centering
%  %\includegraphics[width=\textwidth,height=7cm]{modules} 
%  \includegraphics{reg_net}
%  \caption{Расположение узлов регулярной сетки}
%  \label{fig:reg_net}
%\end{figure}
%\FloatBarrier 

%Интервалы между узлами крупной сетки для удобства
%последовательно пронумеруем номером $i$ (см. рисунок~\ref{fig:reg_net}),
%где $i = 0, \ldots, K-2$.
%Узлы мелкой сетки будем обозначать
%$x_n^k = k+\frac{n}{N},\ k = 0, \ldots, K-2, \  n = 0, \ldots, N-1.$
\end{comment}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Схема вычислений}

Поскольку при дальнейшем изложении удобнее оперировать с 
массивами, введём для них следующие обозначения.
\begin{itemize}

\item
  $F$ обозначим массив размером $K$,
  где содержатся известные значения функции $\varphi$
  в узлах крупной сетки;

\item
  $G_r$ --- массив размером  $M$,
  содержащий 
  значения аппроксимирующей функции в узлах мелкой сетки,
  вычисленные по формуле~\eqref{eq:recv_common}
%
%  $G_0$ и $G_2$ --- массивы размером  $M$,
%  содержащие 
%  значения аппроксимирующей функции в узлах мелкой сетки,
%  вычисленные по формуле~\eqref{eq:recv_common}
%  при $r=0$ (без сглаживания) и при $r=2$ (со сглаживанием) соответственно;

\item
  $\Psi_{r}$ --- массив, содержащий значения ядер В. А. Стеклова порядка $r$.
  %вычисленные по
  %формулам~\eqref{eq:psi_2} и~\eqref{eq:psi_4} соответственно.
%
%  $\Psi_{2}$ и $\Psi_{4}$ --- массивы, содержащие значения ядер
%  В. А. Стеклова $\psi_{2}$ и $\psi_{4}$ вычисленные по
%  формулам~\eqref{eq:psi_2} и~\eqref{eq:psi_4} соответственно.

\end{itemize}

%Учитывая финитность и симметрию ядер В. А. Стеклова
%в массиве $\Psi_{2}$ нужно хранить $N^*$
%значений ядер $\psi_{2}$;
%%на одном интервале крупной сетки;
%в массиве $\Psi_{4}$ нужно хранить $2N^*$
%значений ядер $\psi_{4}$.
%на двух смежных интервалах крупной сетки.

Учитывая финитность и симметрию ядер В. А. Стеклова
в массиве $\Psi_{r}$ нужно хранить $(rN^*)^2/4$
значений.


%Значения массивов $\Psi_{2}$ и $\Psi_{4}$
%вычисляются  один раз 
%на этапе инициализации.
Далее приведены выражения для формирования
элементов искомых значений в узлах мелкой сетки.

Одномерный случай в общем виде:

\begin{equation}
  \label{eq:recv_r0}
  \begin{split}
  G_r(m) &= 
  \sum_{i = 0}^{((r+2)/2 -1)}
  \left(
    F \left( \left \lfloor \frac{m}{N^*} \right \rfloor - i,
      \right)
    \Psi_{r+2}(i*N^* + m\bmod N^*) +{} \right.\\
        & \left. + F \left(
                \left \lfloor \frac{m}{N^*} \right \rfloor + (i+1),
              \right)
            \Psi_{r+2}((i+1)*N^* - m \bmod N^*)
  \right)
  \end{split}
\end{equation}


\begin{equation}
  \label{eq:recv_r0}
  \begin{split}
  G_r(m) &= \sum_{i_2 = 0}^{r_2/2}
  \sum_{i_1 = 0}^{r_1/2}
  \left(
    F \left( \left \lfloor \frac{m_1}{N^*} \right \rfloor - i_1,
             \left \lfloor \frac{m_2}{N^*} \right \rfloor - i_2,
      \right)
    \Psi_{r}(i_1*N^* + m_1\bmod N^*, i_2*N^* + m_2\bmod N^* ) +{} \right.\\
        & \left. + F \left(
                \left \lfloor \frac{m_1}{N^*} \right \rfloor + i_1,
                \left \lfloor \frac{m_2}{N^*} \right \rfloor + i_2
              \right)
            \Psi_{r}(i_1*N^* - m_1 \bmod N^*, i_2*N^* - m_2\bmod N^*)
  \right)
  \end{split}
\end{equation}
где $m = 0, \ldots, M-1$.

\begin{comment}
\begin{itemize}

  \item
Для восстановления данных без сглаживания искомые 
значения в узлах мелкой сетки формируются следующим образом: 
\begin{equation}
  \label{eq:recv_r0}
  \begin{split}
  G_0(m) &=
  F \left( \left \lfloor \frac{m}{N^*} \right \rfloor \right)\Psi_{2}(m\bmod N^*) +{}\\
 &+ F \left( \left \lfloor \frac{m}{N^*} \right \rfloor + 1 \right)\Psi_{2}(N^* - m \bmod N^*),
  \end{split}
\end{equation}
где $m = 0, \ldots, M-1$.

Количество арифметических операций при вычислениях непосредственно по формуле~\eqref{eq:recv_r0}
равно $3M$.
%Вычисления по формуле~\eqref{eq:recv_r0} далее будем обозначать алгоритм А1.

\item
%А при $r = 2$ формула~\eqref{eq:recv_common} 
%представляется следующим образом.
Выражение для восстановления данных со сглаживанием имеет вид:
\begin{equation}
  \label{eq:recv_r2}
\begin{split}
  G_2(m) &=  F \left(\left \lfloor \frac{m}{N^*} \right \rfloor - 1 \right)
              \Psi_{4}(N^* + m \bmod N^*)   + {}\\
              &+ F \left (\left \lfloor \frac{m}{N^*} \right \rfloor \right)
              \Psi_{4}(m \bmod N^*) +{}\\
              &+ F \left( \left \lfloor \frac{m}{N^*} \right \rfloor
              + 1 \right)\Psi_{4}(N^* - m \bmod N^*)  + {}\\
              &+ F \left(\left \lfloor \frac{m}{N^*} \right \rfloor + 2 \right)
              \Psi_{4}(2N^* - m \bmod N^*),
\end{split}
\end{equation}
где $m = 0, \ldots, M-1$.

Количество арифметических операций при вычислениях непосредственно по формуле~\eqref{eq:recv_r2}
равно $7M$.
%Вычисления по формуле~\eqref{eq:recv_r2} далее будем обозначать алгоритм А2.

\end{itemize}
\end{comment}


Заметим, 
что каждое из произведений известного значения в узле крупной сетки
со значениями ядер в узлах мелкой сетки используется несколько раз
при формировании результатов в нескольких соседних
интервалах крупной сетки. 
С учётом этого факта,
предложена следующая двухэтапная вычислительная схема.
\begin{enumerate}
\item
  %Вычисление произведений значений ядер в узлах мелкой сетки
  %для каждого узла крупной сетки.
  Вычисление для $k$-го ($k = 0, \ldots, K-1$)
  известного значения функции 
  элементов массива произведений
  $\Pi_r(k,n_1, n_2) = F(k)\Psi_r(n_1, n_2)$,
  где $n_1=0, \ldots, r*(N^*-1)/2$,
      $n_2=0, \ldots, r*(N^*-1)/2$

  Выполняется $K(rN^*)^2 / 4$ умножений
  

\item
  Выбор и суммирование полученных на предыдущем шаге произведений
  для формирования результирующих значений в узлах мелкой сетки.
  Выполняется $r^2M$ сложений.
  %$M$ сложений в первом варианте и
  %$3M$ сложений --- во втором.
\end{enumerate}

%При такой схеме вычислений общее количество арифметических операций
%для восстановления данных без сглаживания
%составляет $2KN + 2K - N$ (что меньше, чем $3M = 3NK + 3K - 3N$)
%и $5KN + 5K - 3N$ (что меньше, чем $7M = 7NK + 7K - 7N$) для
%восстановления данных со сглаживанием.

%Задача восстановления данных в узлах мелкой сетки
%рассматривается как одна стадия конвейера в модели БСКП.
%ВПД этой стадии является массив $F$ размером $K$,
%содержащий известные
%значения в узлах крупной сетки.
%Обработка ВПД  %восстановления значений в узлах мелкой сетки
%состоит из двух вычислительных процедур,
%соответствующих перечисленным выше этапам.


%%%%%%%%%%%%
%-->
%%%%%%%%%%%
\begin{comment}
\subsection*{Параллельные алгоритмы}
Алгоритмы восстановления данных без сглаживания и со сглаживанием
обладают параллелизмом по данным. 
Пусть данная стадия выполняется на ВВЭ состоящем из  $P$ ЭЦСП.
%Значения в узлах крупной сетки
%распределены между всеми ЭЦСП равномерно и размещены в их глобальной памяти.

Рассмотрим вариант равномерного размещения значений в узлах крупной сетки при условии, что
между вычислительными элементами на обоих уровнях модели БСКП
(т.~е. как между ЭЦСП, так и между ЭВЯ) предполагается обмен данными.
Тогда на $p$-м ЭЦСП ($p = 0, \ldots, P-1$)
обрабатывается $K_p = K/P$ узлов, $K_p < GMem$.
Каждый ЭЦСП 
параллельно с остальными обрабатывает свою часть
крупной сетки из $K_p$ узлов и
формирует часть мелкой сетки размером $M_p = N(K_p-1) + K_p$.
Эти узлы, в свою очередь, 
%распределены,
разбиты 
на ЭПД для вычислений на ЭВЯ.
Размер каждого ЭПД $K_p^j = K_p/N_\text{ЭВЯ}$, где $j = 0, \ldots, N_{\text{ЭВЯ}}-1$.
Здесь, для простоты изложения, считаем, что $K_p^j < {LMem}/{2}$,
$K_p$ кратно $N_{\text{ЭВЯ}}$, а $K$ кратно $P$.
%Если эти условия не выполняются, то потребуется обработка дополнительных ЭПД. 

%При таком размещении исходных узлов 
На втором этапе вычислительной схемы в формировании узлов мелкой сетки
на крайних интервалах каждой из частей крупной сетки  
участвуют произведения, которые оказались вычисленными в соседних
вычислительных элементах. % (ЭЦСП или ЭВЯ).
%Поэтому требуется обмен данными.
В случае восстановления данных без сглаживания
каждый вычислительный элемент должен получить дополнительные $N^*$ значений,
со сглаживанием --- дополнительные $4N^*$ значений.

Если обмен данными между вычислительными элементами на каком-либо из уровней модели БСКП
исключается,  
то необходимо дублировать данные в крайних узлах частей крупной сетки в соседних
вычислительных элементах.
Для алгоритма без сглаживания в каждом вычислительном элементе размещается $K_p+1$ узлов 
крупной сетки и вычисляется на $N^*$ больше произведений,
а для алгоритма со сглаживанием --- по $K_p + 3$ узла
и вычисляется на $4N^*$ произведений больше.


Предложенный подход к распараллеливанию по данным 
эффективен, если на одном ЭЦСП обрабатывается %(без учёта дублирования)
$K_p \ge 2 N_{\text{ЭВЯ}}$ узлов крупной сетки для алгоритма без сглаживания и
$K_p \ge 4 N_{\text{ЭВЯ}}$ узлов для алгоритма co сглаживанием.
Следовательно, границы масштабируемости параллельных алгоритмов восстановления данных 
определются следующими неравенствами:
$P \le \left \lfloor \frac{K}{2N_{\text{ЭВЯ}}} \right \rfloor$ для алгоритма 
без сглаживания и 
$P \le \left \lfloor \frac{K}{4N_{\text{ЭВЯ}}} \right \rfloor$ для
алгоритма со сглаживанием.
%сетки значительно
%больше количества вычислительных элементов и
%выражается следующим
%соотношении размера крупной сетки и количества вычислительных элементов:
%$K \ge 4P$.

%\emph{Тут Можно кол-во операций в табличке представить!}
В таблице~\ref{tab:common_compl} приведены
выражения вычислительной сложности $W$,
коммуникационной сложности $H$ и
количества барьерных синхронизаций $S$,
необходимых для 
трёх вариантов 
параллельных вычислительных алгоритмов
восстановления значений в узлах мелкой сетки %без сглаживания
по формуле~\eqref{eq:recv_r0} и
%со сглаживанием
по формуле~\eqref{eq:recv_r2}.
%на P вычислительных элементах 

\begin{table}[h!] 
  \begin{tabular}{|p{0.17\textwidth}|p{0.38\textwidth}|p{0.38\textwidth}|}
    %%
    \hline
    & без сглаживания & со сглаживанием \\
    \hline
    Без применения двухэтапной вычислительной схемы  &
    %    $$W = \frac{3(NK + K)}{P} - 3N$$
    $$W = 3K_{p}(N + 1) - 3N$$
    $$H = 0; \ S = 0$$ & 
    %    $$W = \frac{7(NK + K)}{P} - 7N$$
    $$W = 7K_{p}(N + 1) - 7N$$
    $$H = 0; \ S = 0$$ 
    \\
    \hline
    По двухэтапной вычислительной схеме с обменами &
    %    $$W = \frac{2(NK + K)}{P} - N$$
    $$W = 2K_{p}(N + 1) - N$$
    $$H = N+1; \ S = 1$$ & 
    %    $$W = \frac{5(NK + K)}{P} - 3N$$
    $$W = 5K_p(N + 1) - 3N$$
    $$H = 4(N+1); \ S = 1$$ 
    \\
    \hline
    По двухэтапной вычислительной схеме без обменов &
    %    $$W = \frac{2(NK + K)}{P} + 1$$
    $$W = 2K_{p}(N + 1) + 1$$
    $$H = 0; \ S = 1$$ & 
    %    $$W = \frac{5(NK + K)}{P} + 3N + 6$$
    $$W = 5K_{p}(N + 1) + N + 4$$
    $$H = 0; \ S = 1$$ 
    \\
    \hline
  \end{tabular}
  \caption {Сводная таблица со сложностями параллельных алгоритмов
    восстановления значений в узлах мелкой сетки}
  \label{tab:common_compl}
\end{table}
%\FloatBarrier 

Из таблицы~\ref{tab:common_compl} видно, что  
алгоритмы с передачей данных и без передачи данных
имеют одинаковую сложность, если пропускная способность, 
с которой вычислительные элементы могут обмениваться данными, равна единице.
Если эта пропускная способность меньше единицы,
то эффективнее алгоритм с передачей данных, а 
если больше, то выгоднее посчитать лишние произведения и данные не передавать.
%Но выбор между алгоритмом с передачей данных и алгоритмом с дополнительными вычислениями,
%но без передачи в конечном итоге зависит от архитектурных особенностей целевой системы.
%Например, даже при условии низкой пропускной способности коммуникационной среды
%если система поддерживает DMA (т. е. предоставляет возможность передачи данных на фоне вычислений),
%то велика вероятность, что эффективнее окажется вариант алгоритма с передачей данных.
\end{comment}


\begin{comment}
\subsection*{Описание программной реализации}

Алгоритмы восстановления данных без сглаживания и со сглаживанием
реализованы в виде библиотеки функций на языке Си.
%Далее рассматриваются подробно действия на каждом из супершагов
%для алгоритмов восстановлений со сглаживанием и без сглаживания.
%При этом именно такая последовательность супершагов в алгоритме со сглаживанием
%позволяет эффективно использовать память.
Каждый из них состоит из двух вычислительных процедур. 
Рассмотрим подробнее реализованные для этих алгоритмов вычислительные процедуры.

\subsubsection{Алгоритм А1 для восстановления данных в узлах мелкой сетки без сглаживания}
%Параллельный алгоритм для 
%вычисления значений в узлах мелкой сетки
%по формуле~\eqref{eq:recv_r0} (т.~е. без сглаживания)
%в терминах модели BSP состоит из двух <<супершагов>>.

\begin{enumerate}
\item
  Каждый вычислительный элемент выполняет следующие действия.
  
  \begin{itemize}
  \item
    Формирует $N^*$ элементов массива произведений
    $\Pi_2$  
    для первого узла 
    части крупной сетки, обрабатываемой на текущем вычислительном элементе.
%    со значениями ядер В. А. Стеклова
%    второго порядка (вычислены на этапе инициализации и хранятся в памяти).
    
  \item
    В случае варианта реализации с обменами:  
    посылает $N^*$ значений сформированных %для крайнего узла крупной сетки
    произведений другому вычислительному элементу
    (где обрабатывается предыдущая часть крупной сетки).
    
  \item
    В случае варианта реализации без обменов:
    вычисляет $N^*$ элементов массива произведений
    $\Pi_2$  
    для дополнительного $K_p$-го узла
    части крупной сетки при наличии этого узла. 
    Если обрабатываемая часть сетки %последняя ---b
    содержит узел с номером $K-1$, то 
    формируется <<код отсутствия>>.
  \end{itemize}
  
\item
  Каждый вычислительный элемент выполняет следующие действия.

  \begin{itemize}
  \item
    В случае варианта реализации с обменами:
    принимает $N^*$ дополнительных значений произведений
    (которые необходимы для формирования
    значений в узлах мелкой сетки на крайнем справа интервале)
    или <<код отсутствия>>,
    если обрабатываемая на вычислительном элементе
    часть сетки %является последней.
    содержит узел с номером $K-1$.
  \item
    В случае варианта реализации без обменов:
    в качестве дополнительных значений используются
    произведения для $K_p$-го узла,
    сформированные текущим вычислительным элементом
    в предыдущей вычислительной процедуре. 
    
  \item
    Независимо формирует оставшиеся $(K_p - 1)N^*$ произведений 
    и вычисляет попарным суммированием соответствующих произведений
    $K_p N^*$ значение в узлах мелкой сетки
    при наличии дополнительных данных %от другого вычислительного элемента
    или
    $(K_p-1) N^*$ значений в случае <<кода отсутствия>>.
  \end{itemize}
\end{enumerate}


\subsubsection{Алгоритм А2 для восстановления данных в узлах мелкой сетки со сглаживанием}
%Параллельный алгоритм для 
%вычисления значений в узлах мелкой сетки со сглаживанием 
%по формуле~\eqref{eq:recv_r2} 
%в терминах модели BSP состоит из двух <<супершагов>>.

\begin{enumerate}
  \item
    Каждый вычислительный элемент выполняет следующие действия.
    \begin{itemize}
    \item
      Формирует %$3(2N + 2) $ значений произведений
      три массива произведений $\Pi_4$ для 
      узлов с номерами 0, 1  и $K_p - 1$ части крупной сетки, обрабатываемой на текущем
      вычислительном элементе. 
%      со значениями
%      ядер В.~А.~Стеклова четвёртого порядка.

    \item
      В случае варианта реализации с обменами: 
      посылает
      $2N^*$ значений произведений для 0-го узла текущей части крупной сетки и  %$K_p - 2$
      $N^*$ значений произведений для 1-го узла текущей части крупной сетки %$K_p - 1$ и
      вычислительному элементу, где обрабатывается предыдущая часть крупной сетки, 
      а $N^*$ значений произведений для последнего узла --- 
      вычислительному элементу, где обрабатывается её следующая часть.

    \item
      В случае варианта реализации без обменов:
      вычисляет $N^*$ элементов массива произведений
      $\Pi_4(n)$, $n = N^*, \ldots, 2N^*-1$, для 
      дополнительного узла слева;
      $2N^*$ элементов массива произведений
      $\Pi_4(n)$, $n = 0, \ldots, 2N^*-1$,
      для первого дополнительного узла справа;  
      $N^*$ элементов массива произведений
      $\Pi_4(n)$, $n = N^*, \ldots, 2N^*-1$, 
      для второго дополнительного узла справа.
      В случае отсутствия какого-либо из дополнительных узлов
      вместо соответствующих произведений формируются <<коды отсутствия>>. 
    \end{itemize}
    
  \item
    Каждый вычислительный элемент выполняет следующие действия.
    \begin{itemize}
    \item
      В случае варианта реализации с обменами: 
      принимает $4N^*$ дополнительных 
      значений произведений
      или <<коды отсутствия>>.
      
    \item
      В случае варианта реализации без обменов:
      вместо принятых значений произведений используются
      произведения для соответствующих дополнительных узлов,
      сформированные текущим вычислительным элементом
      в предыдущей вычислительной процедуре. 

    \item
      Независимо формирует $2N^*(K_p - 3)$
      оставшихся  произведений
      и суммирует по 4 соответствующих произведения, получая
      $K_p N^*$ значений в узлах мелкой сетки при наличии
      дополнительных данных справа или  
      %от вычислительного элемента, где обрабатывается следующая часть исходной крупной сетки или
      $(K_p-1) N^*$ значений --- если часть сетки %является последней.
      содержит узел с номером $K-1$.
    \end{itemize}
\end{enumerate}

 
%\emph{Замечание про <<кольцевой буфер>>.} 
Объединение суммирования с формированием произведений для не крайних
узлов крупной сетки во второй вычислительной процедуре  
позволяет сократить объём памяти, необходимой для хранения
значений произведений. Вместо хранения второго экземпляра мелкой сетки
со всеми значениями произведений можно хранить 
$2 \times N^*$ или
$4 \times 2N^*$
произведений соответственно, которые нужны для
вычисления значений в узлах мелкой сетки на
текущем интервале.
Для организации хранения произведений применяется структура данных
<<кольцевой буфер>>.

\end{comment}

%%
%\bibitem {Zhuk}
%Жук~В.~В. Методические указания к курсу <<Теория аппроксимации функций и ее
%приложения>>. Часть 2. С.-Петербургский ун-т. 1993. 41~с.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper_func_recv"
%%% End: 



