% -*- mode: LaTeX; mode: TeX-PDF; coding: utf-8  -*-


\label{sec:OCLprog}


%\subsection*{Основные обозначения}
\subsection*{Описание программы восстановления данных на OCL}

Исходные данные в оперативной памяти (RAM)
загружаются в глобальную видеопамять (VRAM):
\begin{itemize}
\item
  Массив значений в узлах крупной сетки размером $K = K_y*K_x$.
\item
  Массив значений ядра порядка $r$, вычисленных в
  $(r/2)^2$ ячейках мелкой сетки. Т.е. достаточно хранить
  четверть (правую нижнюю) с учётом финитности ядна и его симметричности по
  обом координатам.
  Инициализируется на CPU.
\end{itemize}

GlobalID (в общем случае вектор) --- координаты вычислительного элемента в пространстве размерности задачи (NDRange).

LocalID --- вектор координат вычислительного элемента в пространстве размерности рабочей группы (Work Group).

Программа для GPU состоит из 2х вычислительных ядер.
\begin{itemize}
\item
  {\bf kernel prod}

  Выполняется в каждой точке крупной сетки.
  Каждый вычислительны элемент (поток)
  получает свою точку крупной сетки
  из глобальной видеопамяти по globalID. 
  
  Размер задачи $K$ (оно же
  максимальное количество параллельно выполняющихся kernel prod).
  Размер задачи для этого ядра одномерный (но мб двумерным сделать для наглядности).

  На выходе формируются массивы произведений в $(r/2)^2$ ячейках мелкой сетки  
  соответствующие каждой точке крупной сетки.
  Выходная структура данных типа map --- для взаимно однозначного соответствия точка -> массив произведений в ячейках.
  Формируется в VRAM, куда каждый вычислительный элемент записывает полученный массив для своей точки по
  глобальному индексу.
  
\item
  {\bf kernel sum}

  Выполняется в каждой точке мелкой сетки.
  Размер задачи $M_y * M_x$.

  
  Каждый вычислительный элемент записывает свою точку мелкой сетки в
  массив в VRAM по GlobalID
\end{itemize}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper_func_recv"
%%% End: 



